import { ConfigOptions } from './types';
import { OperationCollection, transformToHandlerCode, transformToGenerateResultFunctions } from './transform';
import { match } from 'ts-pattern';
import { DEFAULT_MAX_ARRAY_LENGTH, normalizeNonNegativeInt } from './utils';

const getImportsCode = () => {
  const imports = [`import { HttpResponse, http } from 'msw';`, `import { faker } from '@faker-js/faker';`];

  return imports.join('\n');
};

const withApiCounterCode = (options: ConfigOptions) => `
// Map to store counters for each API endpoint
const apiCounters = new Map${options.typescript ? '<string, number>' : ''}();

const next = (apiKey${options.typescript ? ': string' : ''}) => {
  let currentCount = apiCounters.get(apiKey) ?? 0;
  if (currentCount === Number.MAX_SAFE_INTEGER - 1) {
    currentCount = 0;
  }
  apiCounters.set(apiKey, currentCount + 1);
  return currentCount;
};
`;

export const mockTemplate = (operationCollection: OperationCollection, baseURL: string, options: ConfigOptions) => {
  const maxArrayLength = normalizeNonNegativeInt(options?.maxArrayLength, DEFAULT_MAX_ARRAY_LENGTH);
  return `/**
* This file is AUTO GENERATED by [msw-auto-mock](https://github.com/zoubingwu/msw-auto-mock)
* Feel free to commit/edit it as you need.
*/
/* eslint-disable */
/* tslint:disable */
// @ts-nocheck
${getImportsCode()}
${createAiGenerateText(options)}
${withCacheOne(options)}
${withCreatePrompt(options)}

faker.seed(1);

const baseURL = '${baseURL}';
${options.static ? '' : `const MAX_ARRAY_LENGTH = ${maxArrayLength};`}

${withApiCounterCode(options)}

export const handlers = [
  ${transformToHandlerCode(operationCollection, options)}
];

${transformToGenerateResultFunctions(operationCollection, baseURL, options)}
`;
};

export const browserIntegration = [
  `import { setupWorker } from 'msw/browser'`,
  `import { handlers } from './handlers'`,
  `export const worker = setupWorker(...handlers)`,
].join('\n');

export const nodeIntegration = [
  `import { setupServer } from 'msw/node'`,
  `import { handlers } from './handlers'`,
  `export const server = setupServer(...handlers)`,
].join(`\n`);

export const reactNativeIntegration = [
  `import { setupServer } from 'msw/native'`,
  `import { handlers } from './handlers'`,
  // Avoid TS4094 by erasing private/protected members from the inferred class type.
  `type NativeServer = Pick<ReturnType<typeof setupServer>, 'listen' | 'close' | 'use' | 'restoreHandlers' | 'resetHandlers' | 'listHandlers' | 'events'>`,
  `export const server: NativeServer = setupServer(...handlers)`,
].join(`\n`);

const toJsExpr = (value?: string, fallbackExpr = 'undefined') => {
  if (value == null) return fallbackExpr;
  const v = value.trim();
  // If the user already provided an expression or explicit quotes, keep it.
  if (v.startsWith('"') || v.startsWith("'") || v.startsWith('`')) return v;
  if (v.startsWith('process.env.') || v.startsWith('import.meta.env.') || v.startsWith('Deno.env.')) return v;
  if (v.startsWith('globalThis.') || v.startsWith('window.')) return v;
  // Otherwise treat it as a plain string literal.
  return JSON.stringify(v);
};

const askOpenai = (options: ConfigOptions) => `
import { createOpenAI } from '@ai-sdk/openai';
import { generateText } from 'ai';

async function ask(operation) {
  const { text } = await generateText({
    model: createOpenAI({
      apiKey: ${toJsExpr(options.ai?.openai?.apiKey)},
      baseURL: ${toJsExpr(options.ai?.openai?.baseURL)},
    })(${toJsExpr(options.ai?.openai?.model, '"gpt-4o-mini"')}),
    prompt: createPrompt(operation),
  });

  return JSON.parse(text);
}
`;

const askAzure = (options: ConfigOptions) => `
import { createAzure } from '@ai-sdk/azure';
import { generateText } from 'ai';

async function ask(operation) {
  const { text } = await generateText({
    model: createAzure({
      resourceName: ${toJsExpr(options.ai?.azure?.resource)},
      apiKey: ${toJsExpr(options.ai?.azure?.apiKey)}
    })(${toJsExpr(options.ai?.azure?.deployment)}),
    prompt: createPrompt(operation),
  });
  return JSON.parse(text);
}
`;

const askAnthropic = (options: ConfigOptions) => `
import { createAnthropic } from '@ai-sdk/anthropic';
import { generateText } from 'ai';

async function ask(operation) {
  const { text } = await generateText({
    model: createAnthropic({
      apiKey: ${toJsExpr(options.ai?.anthropic?.apiKey)}
    })(${toJsExpr(options.ai?.anthropic?.model, '"claude-3-5-sonnet-latest"')}),
    prompt: createPrompt(operation),
  });
  return JSON.parse(text);
}
`;

const withCreatePrompt = (options: ConfigOptions) =>
  options.ai?.enable
    ? `
function createPrompt(operation) {
  return "Given the following Swagger (OpenAPI) definition, generate a mock data object that conforms to the specified response structure, ensuring each property adheres to its defined constraints, especially type, format, example, description, enum values, ignore the xml field. The generated JSON string should include all the properties defined in the Swagger schema as much as possible and the values should be valid based on the property definitions (e.g., integer, string, length etc.) and rules (e.g, int64 should be string in json etc.). Please only return the JSON string as the output, don't wrap it with markdown. The definition is like below: \\n" + "\`\`\`json" + JSON.stringify(operation, null, 4) + "\\n\`\`\`";
}
`
    : '';

export function createAiGenerateText(options: ConfigOptions): string {
  if (!options.ai?.enable) return '';
  let code = match(options.ai?.provider)
    .with('openai', () => askOpenai(options))
    .with('azure', () => askAzure(options))
    .with('anthropic', () => askAnthropic(options))
    .otherwise(() => '');
  return code;
}

export function withCacheOne(options: ConfigOptions) {
  if (options.static && options.ai?.enable) {
    return `
const cache = new Map();
const withCacheOne = (ask) => async (operation) => {
  const key = operation.verb + ' ' + operation.path;
  if (cache.has(key)) return cache.get(key);
  const value = await ask(operation);
  cache.set(key, value);
  return value;
}`;
  }

  return '';
}
